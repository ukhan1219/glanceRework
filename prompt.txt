is there a way, given the way my project is setup that I can pass the user's information such as id to access items from the database stored under their name using something like getserverauthsession or something, through props or anything else so that I can use more pages on the client and clean up my code, or is it better the way it is setup right now. keep in mind I want to eventually implement a feature that will persists a users plaid data so that they will not have to login to plaid and their bank everytime they use my application, I currently do not know which token would be best used to store for that so if you could help me with that. I want to be able to persist user information like transactions and balance, and then update whenever they login to my app or refresh.help me create the database call to persist the user's plaid data and then update it whenever they login or refresh as well
project directory (i am using mysql for the database):
.
├── README.md
├── next-env.d.ts
├── next.config.js
├── package-lock.json
├── package.json
├── postcss.config.cjs
├── prettier.config.js
├── prisma
│   └── schema.prisma
├── public
│   ├── dicord.png
│   ├── favicon.ico
│   ├── glance.png
│   └── google.png
├── src
│   ├── app
│   │   ├── _components
│   │   │   ├── AccountOverview.tsx
│   │   │   ├── AnalyticsComponent.tsx
│   │   │   ├── LogoutButton.tsx
│   │   │   ├── PlaidLink.tsx
│   │   │   ├── TransactionsContext.tsx
│   │   │   ├── authButtons.tsx
│   │   │   ├── navbar.tsx
│   │   │   └── types.ts
│   │   ├── api
│   │   │   ├── auth
│   │   │   │   └── [...nextauth]
│   │   │   │       └── route.ts
│   │   │   └── trpc
│   │   │       └── [trpc]
│   │   │           └── route.ts
│   │   ├── dashboard
│   │   │   └── page.tsx
│   │   ├── fraudcheck
│   │   │   └── page.tsx
│   │   ├── insights
│   │   │   └── page.tsx
│   │   ├── layout.tsx
│   │   ├── login
│   │   │   └── page.tsx
│   │   ├── page.tsx
│   │   └── prompt.txt
│   ├── env.js
│   ├── server
│   │   ├── api
│   │   │   ├── root.ts
│   │   │   ├── routers
│   │   │   │   ├── openai.ts
│   │   │   │   └── plaid.ts
│   │   │   └── trpc.ts
│   │   ├── auth.ts
│   │   └── db.ts
│   ├── styles
│   │   └── globals.css
│   └── trpc
│       ├── query-client.ts
│       ├── react.tsx
│       └── server.ts
├── start-database.sh
├── tailwind.config.ts
└── tsconfig.json

20 directories, 43 files
schema.prisma:
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "mysql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

model Post {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    createdBy   User   @relation(fields: [createdById], references: [id])
    createdById String

    @@index([name])
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? @db.Text
    access_token             String? @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    image         String?
    accounts      Account[]
    sessions      Session[]
    posts         Post[]
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

accountoverview.tsx:
"use client";

import React, { useState, useContext } from "react";
import PlaidLink from "./PlaidLink";
import { TransactionsContext } from "./TransactionsContext";

export default function AccountOverview() {
  const [openPlaidLink, setOpenPlaidLink] = useState<(() => void) | null>(null);
  const [isPlaidReady, setIsPlaidReady] = useState(false);
  const [balance, setBalance] = useState<string | null>(null);
  const { transactions, setTransactions } = useContext(TransactionsContext)!;
  const [publicToken, setPublicToken] = useState<string | null>(null);

  const handleConnectBank = () => {
    if (openPlaidLink && isPlaidReady) {
      openPlaidLink();
    } else {
      console.log("Plaid link is not ready");
    }
  };

  const handlePlaidSuccess = (token: string) => {
    setPublicToken(token);
  };

  return (
    <div className="col-span-2 row-span-1 relative rounded-xl bg-foreground p-5">
      {/* Balance Display */}
      <div className="mb-5">
        <p className="text-4xl font-bold">
          Balance: <span className="text-green-400">${balance || "N/A"}</span>
        </p>
      </div>

      {/* Transactions List */}
      <div className="mb-5">
        <h2 className="text-2xl font-bold">Recent Transactions</h2>
        <ul>
          {transactions.map((transaction, index) => (
            <li key={index} className="mt-2">
              {transaction.merchantName}:{" "}
              <span className="text-red-500">${transaction.amount}</span>
            </li>
          ))}
        </ul>
      </div>

      {/* Connect Bank Button */}
      {publicToken === null && (
        <button
          className="bg-blue-600 text-white px-4 py-2 rounded-lg"
          onClick={handleConnectBank}
        >
          Connect a Bank with Plaid
        </button>
      )}

      {/* PlaidLink Component */}
      <PlaidLink
        onOpen={(open, ready) => {
          setOpenPlaidLink(() => open);
          setIsPlaidReady(ready);
        }}
        onSuccess={handlePlaidSuccess}
        setBalance={setBalance}
        setTransactions={setTransactions}
      />
    </div>
  );
}
analyticscomponent.tsx:
"use client";

import React, { useEffect, useState, useContext } from 'react';
import { api } from '~/trpc/react';
import { TransactionsContext } from './TransactionsContext';

const AnalyticsComponent: React.FC = () => {
  const { transactions } = useContext(TransactionsContext)!;
  const [analytics, setAnalytics] = useState<string>('');

  const getAnalytics = api.openai.getAnalytics.useMutation();

  useEffect(() => {
    if (transactions.length === 0) return;

    const transactionSummary = transactions
      .map(transaction => `${transaction.merchantName}: $${transaction.amount} on ${transaction.date}, categorized as ${transaction.category}`)
      .join(", ");

    getAnalytics.mutate(
      { transactions: transactionSummary },
      {
        onSuccess: (data) => {
          if (data?.content) {
            setAnalytics(data.content);
          }
        },
      }
    );
  }, [transactions]);

  return (
    <div className='p-4'>
      {getAnalytics.isLoading ? (
        <p>Loading analytics...</p>
      ) : getAnalytics.isError ? (
        <p>Error fetching analytics: {getAnalytics.error.message}</p>
      ) : (
        <div>
          <p>{analytics}</p>
        </div>
      )}
    </div>
  );
};

export default AnalyticsComponent;

authbuttons.tsx:
"use client";

import Image from "next/image";
import googleLogo from "public/google.png";
import discordLogo from "public/dicord.png";
import { signIn } from "next-auth/react";

// Google Sign-In Button
export function GoogleSignInButton() {
    const handleClick = () => {
        signIn("google");
    };

    return (
        <button
            onClick={handleClick}
            className="font-bold w-full flex items-center justify-center h-14 px-6 mt-4 text-l transition-colors duration-300 bg-neutral-300 border-2 border-black text-black rounded-lg focus:shadow-outline hover:bg-neutral-400"
        >
            <Image src={googleLogo} alt="Google Logo" width={20} height={20} />
            <span className="ml-4">Sign in with Google</span>
        </button>
    );
}

// Discord Sign-In Button
export function DiscordSignInButton() {
    const handleClick = () => {
        signIn("discord");
    };

    return (
        <button
            onClick={handleClick}
            className="font-bold w-full flex items-center justify-center h-14 px-6 mt-4 text-l transition-colors duration-300 bg-neutral-300 border-2 border-black text-black rounded-lg focus:shadow-outline hover:bg-neutral-400"
        >
            <Image src={discordLogo} alt="Discord Logo" width={20} height={20} />
            <span className="ml-4">Sign in with Discord</span>
        </button>
    );
}

logoutbutton.tsx:
"use client";

import { signOut } from "next-auth/react"

//  logout button handler
export const LogoutButton  = () => {
    const handleSignout = () => {
        signOut({
            callbackUrl: "/",
        });
    };

    return (
        <button onClick={handleSignout} className="text-red-500 hover:text-red-800 transition-colors duration-300">Logout</button>
    )
}
navbar.tsx:
import { getServerAuthSession } from "~/server/auth";
import Link from "next/link";
import { LogoutButton } from "./LogoutButton";



// navbar component
export const Navbar = async () => {
    const session = await getServerAuthSession();

    return (
        <>
            <header className='navbar z-50 relative'>
                <div className='navbar-start manrope-bold text-5xl  text-[#e5cfa2] hover:text-[#cda24c] transition-colors duration-300 mx-4'>
                    <Link href='/'>
                        Glance
                    </Link>
                </div>

                {/* TODO different colors can be used here, use tailwind color functionality first (text-[color]-[some amount]) */}

                <div className='navbar-center'>
                    <div className='px-5 fira-code-bold text-neutral-content hover:text-neutral-600 transition-colors duration-300 text-sm md:text-base lg:text-lg'>
                        <Link href='/dashboard'>
                            Dashboard
                        </Link>
                    </div>
                    <div className='px-5 fira-code-bold  text-neutral-content hover:text-neutral-600 transition-colors duration-300 text-sm md:text-base lg:text-lg'>
                        <Link href='/insights'>
                            Insights
                        </Link>
                    </div>
                    <div className='px-5 fira-code-bold  text-neutral-content hover:text-neutral-600 transition-colors duration-300 text-sm md:text-base lg:text-lg'>
                        <Link href='/fraudcheck'>
                            FraudCheck
                        </Link>
                    </div>

                </div>

                <div className="navbar-end">
                    <div className='px-5 fira-code-bold  text-neutral-content hover:text-neutral-600 transition-colors duration-300 text-sm md:text-base lg:text-lg'>
                        {session ? (
                            <LogoutButton />
                        ) : (
                            <Link href='/login'>
                                Login
                            </Link>
                        )}
                    </div>
                </div>
            </header>
            <hr className="border-t border-gray-300 mx-5 my-2.5" />

        </>
    );
};
plaidlink.tsx:
"use client";

import React, { useState, useEffect } from "react";
import { usePlaidLink } from "react-plaid-link";
import { api } from '~/trpc/react';
import { Transaction } from './types';

interface PlaidAuthenticationProps {
  publicToken: string;
  setBalance: (balance: string) => void;
  setTransactions: (transactions: Transaction[]) => void;
}

function PlaidAuthentication({ publicToken, setBalance, setTransactions }: PlaidAuthenticationProps) {
  const { mutate: exchangePublicToken, data: dataPub, error: errorPub } = api.plaid.exchangePublicToken.useMutation();
  const { mutate: getAccountBalance, data: dataBalance, error: errorBalance } = api.plaid.getAccountBalance.useMutation();
  const { mutate: getTransactions, data: dataTransactions, error: errorTransactions } = api.plaid.getTransactions.useMutation();

  useEffect(() => {
    exchangePublicToken({ publicToken });
  }, [publicToken, exchangePublicToken]);

  useEffect(() => {
    if (dataPub?.access_token) {
      const accessToken = dataPub.access_token;

      // Fetch account balance
      getAccountBalance({ accessToken });

      // Fetch transactions
      const endDate = new Date().toISOString().split("T")[0]; // Today's date
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 30); // 30 days ago
      const startDateString = startDate.toISOString().split("T")[0];

      getTransactions({ accessToken, startDate: startDateString, endDate });
    }
  }, [dataPub]);

  useEffect(() => {
    if (dataTransactions) {
      const { transactions } = dataTransactions;
      console.log('Transactions:', transactions);
      // Format the transactions to match the Transaction interface
      const formattedTransactions: Transaction[] = transactions.map((txn: any) => ({
        amount: txn.amount,
        category: txn.category,
        date: txn.date,
        merchantName: txn.merchant_name || txn.name || "Unknown",
      }));

      setTransactions(formattedTransactions); // Update context's transactions
    }
  }, [dataTransactions, setTransactions]);

  useEffect(() => {
    if (dataBalance?.accounts) {
      const totalBalance = dataBalance.accounts
        .map((account: any) => account.balances.available)
        .reduce((acc: number, balance: number) => acc + balance, 0);
      setBalance(totalBalance.toFixed(2));
    }
  }, [dataBalance, setBalance]);

  return (
    <div>
      {errorPub && <p>Error exchanging public token: {errorPub.message}</p>}
      {errorBalance && <p>Error fetching account balance: {errorBalance.message}</p>}
      {errorTransactions && <p>Error getting transactions: {errorTransactions.message}</p>}
    </div>
  );
}


interface PlaidLinkProps {
  onOpen: (openPlaid: () => void, ready: boolean) => void;
  onSuccess: (token: string) => void;
  setBalance: (balance: string) => void;
  setTransactions: (transactions: Transaction[]) => void; // Use Transaction[] for transactions
}

const PlaidLink = React.memo(({ onOpen, onSuccess, setBalance, setTransactions }: PlaidLinkProps) => {
  // TODO CLIENT USER ID SO I CAN PERSIST
  const [clientUserId] = useState("your-client-user-id"); 
  const [linkToken, setLinkToken] = useState<string | undefined>(undefined);
  const [publicToken, setPublicToken] = useState<string | undefined>(undefined);
  const { mutate: createLinkToken, data, error } = api.plaid.createLinkToken.useMutation();

  useEffect(() => {
    createLinkToken({ clientUserId });
  }, [clientUserId, createLinkToken]);

  useEffect(() => {
    if (data?.link_token) {
      setLinkToken(data.link_token);
    }
  }, [data]);

  const { open, ready } = usePlaidLink({
    token: linkToken || "",
    onSuccess: (public_token) => {
      setPublicToken(public_token);
      onSuccess(public_token);
    },
  });

  useEffect(() => {
    if (onOpen && ready) {
        onOpen(open as () => void, ready);
      }
  }, [onOpen, open, ready]);

  return publicToken ? (
    <PlaidAuthentication
      publicToken={publicToken}
      setBalance={setBalance}
      setTransactions={setTransactions} // Ensure it's passed here
    />
  ) : (
    <div>{error && <p>Error: {error.message}</p>}</div>
  );
});

export default PlaidLink;
TransactionsContext.tsx:
// src/app/_components/TransactionsContext.tsx
"use client";

import React, { createContext, useState } from 'react';
import { Transaction } from './types';

interface TransactionsContextType {
  transactions: Transaction[];
  setTransactions: React.Dispatch<React.SetStateAction<Transaction[]>>;
}

export const TransactionsContext = createContext<TransactionsContextType | undefined>(undefined);

export const TransactionsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [transactions, setTransactions] = useState<Transaction[]>([]);

  return (
    <TransactionsContext.Provider value={{ transactions, setTransactions }}>
      {children}
    </TransactionsContext.Provider>
  );
};
types.ts:
export interface Transaction {
    amount: number;
    category: string[];
    date: string;
    merchantName: string;
  }
  
dashboard/page.tsx:


import React from 'react';
import { getServerAuthSession } from '~/server/auth';
import { redirect } from 'next/navigation';
import AccountOverview from '../_components/AccountOverview';
import AnalyticsComponent from '../_components/AnalyticsComponent';
import { TransactionsProvider } from '../_components/TransactionsContext';

export default async function DashboardPage() {
  const session = await getServerAuthSession();

  if (!session) {
    return redirect('/login');
  }

  return (
    <div className='h-[calc(100vh-85px)] w-full flex items-center justify-center'>
      <TransactionsProvider>
        <div className='grid h-full w-full grid-cols-3 grid-rows-2 gap-2.5 p-5 xl:m-32 lg:m-16 md:m-8 sm:m-4'>
          {/* Grid Box 1 */}
          <div className='col-span-2 row-span-1 relative rounded-xl bg-foreground overflow-hidden'>
            {/* Scrollable Content */}
            <div className='h-full hide-scrollbar overflow-auto rounded-xl p-4 pb-12 relative'>
              <AccountOverview />
            </div>
            {/* Label anchored to the bottom-left */}
            <div className="absolute bottom-0 left-0 w-full bg-opacity-90 bg-foreground py-2 px-4 flex items-center justify-between z-10">
              <p className="text-lg font-bold">Account Overview</p>
              {/* Scroll Indicator */}
              <div className="flex items-center">
                <span className="text-sm">More</span>
                <svg className="w-4 h-4 ml-1 animate-bounce" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  {/* Down arrow icon */}
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 5v14m7-7H5" />
                </svg>
              </div>
            </div>
          </div>

          {/* Grid Box 2 */}
          <div className='col-span-1 row-span-1 relative rounded-xl bg-foreground'>
            <div className="absolute bottom-1 left-2">
              <p className="text-lg font-bold">GRID LABEL HERE</p>
            </div>
          </div>

          {/* Grid Box 3 */}
          <div className='col-span-3 row-span-1 relative rounded-xl bg-foreground overflow-hidden'>
            <div className='h-full hide-scrollbar overflow-auto rounded-xl p-4 pb-12 text-2xl relative'>
              <AnalyticsComponent />
            </div>
            <div className="absolute bottom-0 left-0 w-full bg-opacity-90 bg-foreground py-2 px-4 flex items-center justify-between z-10">
              <p className="text-lg font-bold">Analytics</p>
              {/* Scroll Indicator */}
              <div className="flex items-center">
                <span className="text-sm">More</span>
                <svg className="w-4 h-4 ml-1 animate-bounce" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  {/* Down arrow icon */}
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 5v14m7-7H5" />
                </svg>
              </div>
            </div>
          </div>
        </div>
      </TransactionsProvider>
    </div>
  );
}
layout.tsx:
import "~/styles/globals.css";
import { type Metadata } from "next";
import { TRPCReactProvider } from "~/trpc/react";
import { Navbar } from "./_components/navbar";

export const metadata: Metadata = {
  title: "Glance",
  description: "Your Personal Finance, at a Glance",
  icons: {
    icon: "/favicon.ico",
  },
};

// This function does not need to be changed

export default function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  return (
    <html lang="en">
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="true" />
        <link
          href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Manrope:wght@200..800&display=swap"
          rel="stylesheet"
        />
      </head>
      <body>
        <Navbar />
        <TRPCReactProvider>{children}</TRPCReactProvider>
      </body>
    </html>
  );
}
page.tsx:
import React from "react";
import Image from "next/image";
import glancePNG from "public/glance.png";
import { HydrateClient } from "~/trpc/server";

export default async function Home() {
  return (
    <HydrateClient>
      {/* Main container */}
      <div className="bg-[#292464] min-h-screen flex flex-col justify-between">
        {/* Main content section */}
        <div className="flex-grow flex items-center justify-center">
          <div className="flex flex-col md:flex-row w-11/12 lg:w-10/12">
            {/* Left Section - Text Section (responsive from full width to 2/3 on larger screens) */}
            <div className="w-full md:w-8/12 p-6 md:p-10 flex flex-col justify-center">
              <p
                className="fira-sans-regular text-neutral-content text-lg md:text-2xl lg:text-3xl font-bold"
              >
                Take Control of Your Finances with Glance
              </p>
              <p className="fira-sans-regular text-neutral-content mt-4 text-sm md:text-base lg:text-lg">
                Glance is your all-in-one financial hub, seamlessly connecting all your accounts in one place. Whether it's your checking or savings accounts, stocks, crypto holdings, or other investments, Glance provides a clear overview of your entire financial landscape. Monitor balances, track your assets, and manage your wealth with ease—all in a simple, intuitive interface. Stay informed, make smarter decisions, and unlock the power of your finances.
              </p>
            </div>

            {/* Right Section - Image Section (responsive from full width to 1/3 on larger screens) */}
            <div className="w-full md:w-4/12 flex justify-center items-center mt-8 md:mt-0">
              <div className="bg-foreground w-3/4 h-auto rounded-lg flex items-center justify-center p-6 md:p-10">
                <Image src={glancePNG} alt="Logo" className="w-full h-auto" />
              </div>
            </div>
          </div>
        </div>

        {/* Footer section */}
        <footer className="bg-gray-900 py-4">
          <div className="text-center text-sm text-gray-500">
            © 2024 Glance. All rights reserved.
          </div>
        </footer>
      </div>
    </HydrateClient>
  );
}
openai.ts:
import { z } from 'zod';
import { createTRPCRouter, protectedProcedure } from '../trpc';
import OpenAI from 'openai';

const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});

const model = "gpt-4-turbo"
// OR "gpt-4o"

export const openaiRouter = createTRPCRouter({
    getAnalytics: protectedProcedure.input(z.object({transactions: z.string(),})).mutation(async ({ input }) => {

        try {
            const prompt = `LIMIT TO 250 TOKENS; DO NOT USE MARKDOWN FORMAT (meaning do not use asterisks or hashtags since it will ruin the formatting of my website): Here are my recent transactions, I want you to  generate a summary of my spending habits: ${input.transactions}, and also mark the categories I spent the most money in and suggestions on how to budget myself better and save money. Keep it personalized, not generalized advice.`;

            const response = await openai.chat.completions.create({
                model: model,
                messages: [
                    {role: "system", content: "You are a helpful financial analyst/assistant."},
                    {role: "user", content: prompt}
                ],
                max_tokens: 250,
                temperature: 1,
            });

            console.log(response.choices[0].message);
            return response.choices[0].message;
        }   catch (error) {
            console.error("Error querying OpenAI API: ",error);
            throw new Error("Error querying OpenAI API")
        }
    }),


})
plaid.ts:

import { z } from 'zod';
import { createTRPCRouter, protectedProcedure } from '~/server/api/trpc';
import { Configuration, PlaidApi, PlaidEnvironments, CountryCode, Products} from 'plaid';

// Configure the Plaid client
const configuration = new Configuration({
  basePath: PlaidEnvironments.sandbox,
  baseOptions: {
    headers: {
      'PLAID-CLIENT-ID': process.env.PLAID_CLIENT_ID || '',
      'PLAID-SECRET': process.env.PLAID_SECRET || '',
    },
  },
});

const plaidClient = new PlaidApi(configuration);

// Define the tRPC router for Plaid operations
export const plaidRouter = createTRPCRouter({
  createLinkToken: protectedProcedure
    .input(z.object({ clientUserId: z.string() }))
    .mutation(async ({ input }) => {
      const { clientUserId } = input;

      const request = {
        user: {
          client_user_id: clientUserId,
        },
        client_name: 'Plaid Test App',
        products: [Products.Auth, Products.Transactions], // Include 'transactions' here
        language: 'en',
        redirect_uri: 'http://localhost:3000/',
        country_codes: [CountryCode.Us],
      };

      try {
        const createTokenResponse = await plaidClient.linkTokenCreate(request);
        return createTokenResponse.data;
      } catch (error) {
        console.error('Error creating link token:', error);
        throw new Error('Failed to create link token');
      }
    }),
  exchangePublicToken: protectedProcedure
    .input(z.object({ publicToken: z.string(), }))
    .mutation(async ({ input }) => {
      const { publicToken } = input;


      try {
        const response = await plaidClient.itemPublicTokenExchange({ public_token: publicToken, });

        const { access_token, item_id } = response.data;

        // await db.saveAccessToken(userId, access_token);

        return {
          public_token_exchange: 'complete',
          access_token,
          item_id,
        };
      } catch (error) {
        throw new Error('Failed to exchange public token');
      }
    }),

  getAccountBalance: protectedProcedure
    .input(z.object({ accessToken: z.string() }))  // Input is the access token
    .mutation(async ({ input }) => {
      const { accessToken } = input;

      try {
        const request = {
          access_token: accessToken,
        };
        const response = await plaidClient.accountsBalanceGet(request);

        const { accounts } = response.data;

        return { accounts };  // Return the account balances
      } catch (error) {
        throw new Error('Failed to get account balance');
      }
    }),

  syncTransactions: protectedProcedure
    .input(
      z.object({
        accessToken: z.string(),
        cursor: z.string().optional(), // Optional cursor for pagination
      })
    )
    .mutation(async ({ input }) => {
      const { accessToken, cursor } = input;

      let added: Array<any> = [];
      let modified: Array<any> = [];
      let removed: Array<any> = [];
      let hasMore = true;
      let newCursor = cursor;

      try {
        while (hasMore) {
          const request = {
            access_token: accessToken,
            cursor: newCursor,
          };
          const response = await plaidClient.transactionsSync(request);
          const data = response.data;

          // Concatenate new data
          added = added.concat(data.added);
          modified = modified.concat(data.modified);
          removed = removed.concat(data.removed);

          // Update cursor and hasMore flag
          newCursor = data.next_cursor;
          hasMore = data.has_more;
        }

        // Return the transactions and the new cursor
        return {
          added,
          modified,
          removed,
          cursor: newCursor,
        };
      } catch (error) {
        throw new Error('Failed to sync transactions');
      }
    }),

  getTransactions: protectedProcedure
    .input(
      z.object({
        accessToken: z.string(),
        startDate: z.string(), // ISO 8601 date string
        endDate: z.string(),   // ISO 8601 date string
      })
    )
    .mutation(async ({ input }) => {
      const { accessToken, startDate, endDate } = input;

      try {
        const request = {
          access_token: accessToken,
          start_date: startDate,
          end_date: endDate,
        };
        const response = await plaidClient.transactionsGet(request);
        const data = response.data;

        // Return the transactions and other relevant data
        return {
          accounts: data.accounts,
          transactions: data.transactions,
          total_transactions: data.total_transactions,
        };
      } catch (error: any) {  // Casting error to 'any'
        console.error('Error getting transactions:', error.response?.data || error);
        throw new Error('Failed to get transactions: ' + (error.response?.data?.error_message || error.message));
      }
    }),
});


// getTransactions: protectedProcedure
root.ts:
import { createCallerFactory, createTRPCRouter } from "~/server/api/trpc";
import { plaidRouter } from "./routers/plaid";
import { openaiRouter } from "./routers/openai";
/**
 * This is the primary router for your server.
 *
 * All routers added in /api/routers should be manually added here.
 */
export const appRouter = createTRPCRouter({
  plaid: plaidRouter,
  openai: openaiRouter,
});

// export type definition of API
export type AppRouter = typeof appRouter;

/**
 * Create a server-side caller for the tRPC API.
 * @example
 * const trpc = createCaller(createContext);
 * const res = await trpc.post.all();
 *       ^? Post[]
 */
export const createCaller = createCallerFactory(appRouter);
trpc.ts:
/**
 * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:
 * 1. You want to modify request context (see Part 1).
 * 2. You want to create a new middleware or type of procedure (see Part 3).
 *
 * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will
 * need to use are documented accordingly near the end.
 */

import { initTRPC, TRPCError } from "@trpc/server";
import superjson from "superjson";
import { ZodError } from "zod";

import { getServerAuthSession } from "~/server/auth";
import { db } from "~/server/db";

/**
 * 1. CONTEXT
 *
 * This section defines the "contexts" that are available in the backend API.
 *
 * These allow you to access things when processing a request, like the database, the session, etc.
 *
 * This helper generates the "internals" for a tRPC context. The API handler and RSC clients each
 * wrap this and provides the required context.
 *
 * @see https://trpc.io/docs/server/context
 */
export const createTRPCContext = async (opts: { headers: Headers }) => {
  const session = await getServerAuthSession();

  return {
    db,
    session,
    ...opts,
  };
};

/**
 * 2. INITIALIZATION
 *
 * This is where the tRPC API is initialized, connecting the context and transformer. We also parse
 * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation
 * errors on the backend.
 */
const t = initTRPC.context<typeof createTRPCContext>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.cause instanceof ZodError ? error.cause.flatten() : null,
      },
    };
  },
});

/**
 * Create a server-side caller.
 *
 * @see https://trpc.io/docs/server/server-side-calls
 */
export const createCallerFactory = t.createCallerFactory;

/**
 * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)
 *
 * These are the pieces you use to build your tRPC API. You should import these a lot in the
 * "/src/server/api/routers" directory.
 */

/**
 * This is how you create new routers and sub-routers in your tRPC API.
 *
 * @see https://trpc.io/docs/router
 */
export const createTRPCRouter = t.router;

/**
 * Middleware for timing procedure execution and adding an artificial delay in development.
 *
 * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating
 * network latency that would occur in production but not in local development.
 */
const timingMiddleware = t.middleware(async ({ next, path }) => {
  const start = Date.now();

  if (t._config.isDev) {
    // artificial delay in dev
    const waitMs = Math.floor(Math.random() * 400) + 100;
    await new Promise((resolve) => setTimeout(resolve, waitMs));
  }

  const result = await next();

  const end = Date.now();
  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);

  return result;
});

/**
 * Public (unauthenticated) procedure
 *
 * This is the base piece you use to build new queries and mutations on your tRPC API. It does not
 * guarantee that a user querying is authorized, but you can still access user session data if they
 * are logged in.
 */
export const publicProcedure = t.procedure.use(timingMiddleware);

/**
 * Protected (authenticated) procedure
 *
 * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies
 * the session is valid and guarantees `ctx.session.user` is not null.
 *
 * @see https://trpc.io/docs/procedures
 */
export const protectedProcedure = t.procedure
  .use(timingMiddleware)
  .use(({ ctx, next }) => {
    if (!ctx.session || !ctx.session.user) {
      throw new TRPCError({ code: "UNAUTHORIZED" });
    }
    return next({
      ctx: {
        // infers the `session` as non-nullable
        session: { ...ctx.session, user: ctx.session.user },
      },
    });
  });
auth.ts:
import { PrismaAdapter } from "@auth/prisma-adapter";
import {
  getServerSession,
  type DefaultSession,
  type NextAuthOptions,
} from "next-auth";
import { type Adapter } from "next-auth/adapters";
import DiscordProvider from "next-auth/providers/discord";
import GoogleProvider from "next-auth/providers/google";

import { env } from "~/env";
import { db } from "~/server/db";

/**
 * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`
 * object and keep type safety.
 *
 * @see https://next-auth.js.org/getting-started/typescript#module-augmentation
 */
declare module "next-auth" {
  interface Session extends DefaultSession {
    user: {
      id: string;
      // ...other properties
      // role: UserRole;
    } & DefaultSession["user"];
  }

  // interface User {
  //   // ...other properties
  //   // role: UserRole;
  // }
}

/**
 * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.
 *
 * @see https://next-auth.js.org/configuration/options
 */
export const authOptions: NextAuthOptions = {
  callbacks: {
    session: ({ session, user }) => ({
      ...session,
      user: {
        ...session.user,
        id: user.id,
      },
    }),
  },
  adapter: PrismaAdapter(db) as Adapter,
  providers: [
    DiscordProvider({
      clientId: env.DISCORD_CLIENT_ID,
      clientSecret: env.DISCORD_CLIENT_SECRET,
    }),
    GoogleProvider({
      clientId: env.GOOGLE_CLIENT_ID,
      clientSecret: env.GOOGLE_CLIENT_SECRET,
    }),
  ],
};

/**
 * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.
 *
 * @see https://next-auth.js.org/configuration/nextjs
 */
export const getServerAuthSession = () => getServerSession(authOptions);
db.ts:
import { PrismaClient } from "@prisma/client";

import { env } from "~/env";

const createPrismaClient = () =>
  new PrismaClient({
    log:
      env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  });

const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined;
};

export const db = globalForPrisma.prisma ?? createPrismaClient();

if (env.NODE_ENV !== "production") globalForPrisma.prisma = db;
